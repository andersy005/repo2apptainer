import argparse
import sys
import os
import logging
import docker
from repo2singularity import __version__
from repo2docker.utils import (
    validate_and_generate_port_mapping,
    is_valid_docker_image_name,
)
from repo2singularity import Repo2Singularity


def validate_image_name(image_name):
    """
    Validate image_name read by argparse

    Note: Container names must start with an alphanumeric character and
    can then use _ . or - in addition to alphanumeric.
    [a-zA-Z0-9][a-zA-Z0-9_.-]+

    Args:
        image_name (string): argument read by the argument parser

    Returns:
        unmodified image_name

    Raises:
        ArgumentTypeError: if image_name contains characters that do not
                            meet the logic that container names must start
                            with an alphanumeric character and can then
                            use _ . or - in addition to alphanumeric.
                            [a-zA-Z0-9][a-zA-Z0-9_.-]+
    """
    if not is_valid_docker_image_name(image_name):
        msg = (
            '%r is not a valid docker image name. Image name'
            'must start with an alphanumeric character and'
            'can then use _ . or - in addition to alphanumeric.' % image_name
        )
        raise argparse.ArgumentTypeError(msg)
    return image_name


# See https://github.com/jupyter/Repo2Singularity/issues/871 for reason
class MimicDockerEnvHandling(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        # There are 3 cases:
        #  key=value    pass as is
        #  key=         pass as is
        #  key          pass using current value, or don't pass
        if '=' not in values:
            try:
                value_to_append = '{}={}'.format(values, os.environ[values])
            except KeyError:
                # no local def, so don't pass
                return
        else:
            value_to_append = values

        # destination variable is initially defined as an empty list, so
        # no special casing of first time is needed.
        getattr(namespace, self.dest).append(value_to_append)


def get_argparser():
    """Get arguments that may be used by Repo2Singularity"""
    argparser = argparse.ArgumentParser(
        description='Fetch a repository and build a container image'
    )

    argparser.add_argument(
        '--config',
        default='Repo2Singularity_config.py',
        help='Path to config file for Repo2Singularity',
    )

    argparser.add_argument(
        '--json-logs',
        default=False,
        action='store_true',
        help='Emit JSON logs instead of human readable logs',
    )

    argparser.add_argument(
        'repo',
        help=(
            'Path to repository that should be built. Could be local path or a git URL.'
        ),
    )

    argparser.add_argument(
        '--image-name',
        help=('Name of image to be built. If unspecified will be ' 'autogenerated'),
        type=validate_image_name,
    )

    argparser.add_argument(
        '--ref',
        help=(
            'If building a git url, which reference to check out. ' 'E.g., `master`.'
        ),
    )

    argparser.add_argument('--debug', help='Turn on debug logging', action='store_true')

    argparser.add_argument(
        '--no-build',
        dest='build',
        action='store_false',
        help=(
            'Do not actually build the image. Useful in conjunction ' 'with --debug.'
        ),
    )

    argparser.add_argument(
        '--build-memory-limit',
        help='Total Memory that can be used by the docker build process',
    )

    argparser.add_argument(
        'cmd',
        nargs=argparse.REMAINDER,
        help='Custom command to run after building container',
    )

    argparser.add_argument(
        '--no-run',
        dest='run',
        action='store_false',
        help='Do not run container after it has been built',
    )

    argparser.add_argument(
        '--publish',
        '-p',
        dest='ports',
        action='append',
        help=(
            'Specify port mappings for the image. Needs a command to '
            'run in the container.'
        ),
    )

    argparser.add_argument(
        '--publish-all',
        '-P',
        dest='all_ports',
        action='store_true',
        help='Publish all exposed ports to random host ports.',
    )

    argparser.add_argument(
        '--no-clean',
        dest='clean',
        action='store_false',
        help="Don't clean up remote checkouts after we are done",
    )

    argparser.add_argument(
        '--push',
        dest='push',
        action='store_true',
        help='Push docker image to repository',
    )

    argparser.add_argument(
        '--volume',
        '-v',
        dest='volumes',
        action='append',
        help='Volumes to mount inside the container, in form src:dest',
        default=[],
    )

    argparser.add_argument(
        '--user-id', help='User ID of the primary user in the image', type=int
    )

    argparser.add_argument(
        '--user-name', help='Username of the primary user in the image'
    )

    # Process the environment options the same way that docker does, as
    # they are passed directly to docker as the environment to use. This
    # requires a custom action for argparse.
    argparser.add_argument(
        '--env',
        '-e',
        dest='environment',
        action=MimicDockerEnvHandling,
        help='Environment variables to define at container run time',
        default=[],
    )

    argparser.add_argument(
        '--editable',
        '-E',
        dest='editable',
        action='store_true',
        help='Use the local repository in edit mode',
    )

    argparser.add_argument(
        '--target-repo-dir', help=Repo2Singularity.target_repo_dir.help
    )

    argparser.add_argument('--appendix', type=str, help=Repo2Singularity.appendix.help)

    argparser.add_argument('--subdir', type=str, help=Repo2Singularity.subdir.help)

    argparser.add_argument(
        '--version',
        dest='version',
        action='store_true',
        help='Print the Repo2Singularity version and exit.',
    )

    argparser.add_argument(
        '--cache-from',
        action='append',
        default=[],
        help=Repo2Singularity.cache_from.help,
    )

    return argparser


argparser = get_argparser()


def make_r2s(argv=None):
    if argv is None:
        argv = sys.argv[1:]

    # version must be checked before parse, as repo/cmd are required and
    # will spit out an error if allowed to be parsed first.
    if '--version' in argv:
        print(__version__)
        sys.exit(0)

    args = get_argparser().parse_args(argv)

    r2s = Repo2Singularity()

    if args.debug:
        r2s.log_level = logging.DEBUG

    r2s.load_config_file(args.config)
    if args.appendix:
        r2s.appendix = args.appendix

    r2s.repo = args.repo
    r2s.ref = args.ref

    # user wants to mount a local directory into the container for
    # editing
    if args.editable:
        # the user has to point at a directory, not just a path for us
        # to be able to mount it. We might have content providers that can
        # provide content from a local `something.zip` file, which we
        # couldn't mount in editable mode
        if os.path.isdir(args.repo):
            r2s.volumes[os.path.abspath(args.repo)] = '.'
        else:
            r2s.log.error(
                'Cannot mount "{}" in editable mode '
                'as it is not a directory'.format(args.repo),
                extra=dict(phase='failed'),
            )
            sys.exit(1)

    if args.image_name:
        r2s.output_image_spec = args.image_name
    else:
        # we will pick a name after fetching the repository
        r2s.output_image_spec = ''

    r2s.json_logs = args.json_logs

    r2s.dry_run = not args.build

    if r2s.dry_run:
        # Can't push nor run if we aren't building
        args.run = False
        args.push = False

    r2s.run = args.run
    r2s.push = args.push

    # check against r2s.run and not args.run as r2s.run is false on
    # --no-build. Also r2s.volumes and not args.volumes since --editable
    # modified r2s.volumes
    if r2s.volumes and not r2s.run:
        # Can't mount if we aren't running
        print('To Mount volumes with -v, you also need to run the ' 'container')
        sys.exit(1)

    for v in args.volumes:
        src, dest = v.split(':')
        r2s.volumes[src] = dest

    r2s.run_cmd = args.cmd

    if args.all_ports and not r2s.run:
        print(
            'To publish user defined port mappings, the container must ' 'also be run'
        )
        sys.exit(1)

    if args.ports and not r2s.run:
        print(
            'To publish user defined port mappings, the container must ' 'also be run'
        )
        sys.exit(1)

    if args.ports and not r2s.run_cmd:
        print(
            'To publish user defined port mapping, user must specify '
            'the command to run in the container'
        )
        sys.exit(1)

    r2s.ports = validate_and_generate_port_mapping(args.ports)
    r2s.all_ports = args.all_ports

    if args.user_id:
        r2s.user_id = args.user_id
    if args.user_name:
        r2s.user_name = args.user_name
    if r2s.user_id == 0 and not r2s.dry_run:
        print('Root as the primary user in the image is not permitted.')
        print(
            'The uid and the username of the user invoking Repo2Singularity '
            'is used to create a mirror account in the image by default. '
            'To override that behavior pass --user-id <numeric_id> and '
            ' --user-name <string> to Repo2Singularity.\n'
            'Please see Repo2Singularity --help for more details.\n'
        )
        sys.exit(1)

    if args.build_memory_limit:
        # if the string only contains numerals we assume it should be an int
        # and specifies a size in bytes
        if args.build_memory_limit.isnumeric():
            r2s.build_memory_limit = int(args.build_memory_limit)
        else:
            r2s.build_memory_limit = args.build_memory_limit

    if args.environment and not r2s.run:
        print('To specify environment variables, you also need to run ' 'the container')
        sys.exit(1)

    if args.subdir:
        r2s.subdir = args.subdir

    if args.cache_from:
        r2s.cache_from = args.cache_from

    r2s.environment = args.environment

    # if the source exists locally we don't want to delete it at the end
    # FIXME: Find a better way to figure out if repo is 'local'. Push this into ContentProvider?
    if os.path.exists(args.repo):
        r2s.cleanup_checkout = False
    else:
        r2s.cleanup_checkout = args.clean

    if args.target_repo_dir:
        r2s.target_repo_dir = args.target_repo_dir

    return r2s


def main():
    r2s = make_r2s()
    r2s.initialize()
    try:
        r2s.start()
    except docker.errors.BuildError as e:
        # This is only raised by us
        if r2s.log_level == logging.DEBUG:
            r2s.log.exception(e)
        sys.exit(1)
    except docker.errors.ImageLoadError as e:
        # This is only raised by us
        if r2s.log_level == logging.DEBUG:
            r2s.log.exception(e)
        sys.exit(1)


if __name__ == '__main__':
    main()
